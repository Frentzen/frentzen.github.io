---
layout: post
title: "From CVE-2022-22980 to a Real Exploit Path: my code-review playbook"
description: How I turned a CVE blurb into an actionable finding using grep/CodeQL, and what to fix.
categories:
  - security
  - code-review
tags:
  - CVE-2022-22980
  - Spring
  - Data
  - MongoDB
  - SpEL
  - CodeQL
  - appsec
---
> TL;DR ‚Äî This post shows how I go from ‚Äúthere‚Äôs a critical CVE in our deps‚Äù to **‚Äúhere‚Äôs the exact code path that‚Äôs exploitable‚Äù**, using a quick pattern hunt and a tiny CodeQL query. It also covers what to change in code, not just ‚Äúupgrade the library‚Äù.

---
## Why this CVE caught my eye

When **CVE-2022-22980** dropped, the headlines said *‚ÄúSpEL Injection in Spring Data MongoDB, potentially RCE‚Äù*. That‚Äôs a lot of noise for triage, so I wanted to answer two questions fast:

1) **Do we have the vulnerable pattern in our code?**  
2) **Is there a realistic input ‚Üí sink path, or is this dead code?**

You‚Äôre typically at risk if **all** are true:

- You use Spring Data MongoDB with repository methods annotated with `@Query` or `@Aggregation`.
- Inside those annotations, you embed **SpEL** and reference parameters using **positional placeholders** such as `?0`, `?1` **inside** the SpEL expression.
- That parameter flows from **unsanitized user input**.

**Good news:** fixed releases exist. If you can‚Äôt upgrade immediately, **array-style parameter access** like `[0]` *inside SpEL* avoids this specific bug pattern.

---
## The pattern I hunt for (fast triage)

I start broad with ripgrep, then narrow down to **SpEL + positional parameters**.

**Step 1 ‚Äî find repository annotations**

```shell
rg -n "@Query|@Aggregation" --glob "**/*.java"
```

**Step 2 ‚Äî find SpEL blocks inside annotations** (the tell: `?#{ ... }`)

```shell
rg -n "?\#\{" --glob "**/*.java"
```

**Step 3 ‚Äî flag positional placeholders used *inside* SpEL**

```shell
rg -n "@Query\([^)]*\?\#\{[^)]*\?[0-9]" --glob "**/*.java"
```

üëâ I‚Äôm specifically chasing **SpEL + `?0` inside the expression**.  
If I only see **array syntax** like `[0]` or plain parameter binding without SpEL, I **downgrade** the risk.

---
## Proving there‚Äôs a path (bite-size CodeQL)

Once I‚Äôve got candidates, I confirm that **remote input** can reach one of those annotated methods.

```codeql
/**
 * Find flows from remote inputs into methods annotated with @Query/@Aggregation
 * where the annotation text contains ?<digit> inside a SpEL block.
 */
import java
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.DataFlow
import DataFlow::PathGraph

class Cve22980Conf extends DataFlow::Configuration {
  Cve22980Conf() { this = "CVE-2022-22980" }

  override predicate isSource(DataFlow::Node s) {
    exists(RemoteFlowSource r | s.asParameter() = r.asParameter())
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(Method m, Annotation a, MethodAccess call |
      a = m.getAnAnnotation() and
      (a.toString() = "Query" or a.toString() = "Aggregation") and
      a.getAValue().toString().regexpMatch(".*\\?\\#\\{.*\\?[0-9].*") and
      call.getMethod() = m and
      call.getAnArgument() = sink.asExpr()
    )
  }
}

from Cve22980Conf conf, DataFlow::PathNode src, DataFlow::PathNode snk
where conf.hasFlowPath(src, snk)
select snk, src, "Possible SpEL injection path (CVE-2022-22980)"
```

If this returns a **short, direct path** (e.g., controller ‚Üí repository), I treat it as **exploitable** and move straight to remediation.

---
## What exploitation looks like (high level)

- Attackers craft a value that‚Äôs **evaluated by SpEL during query assembly**.
- This can trigger even in ‚Äúread-only‚Äù looking code, because evaluation happens **before** the DB call.
- Keep testing to a **throwaway local lab** you control.

---
## How I fix it (in code)

**Best:** upgrade `spring-data-mongodb` to a **fixed release**.

**If you can‚Äôt upgrade:**

- **Stop using** `?0` (etc.) **inside SpEL.** Replace with **array syntax** `[0] *inside* the expression.
- Or **avoid SpEL in annotations** entirely: build the query in a **custom repository** using the Criteria API and bind parameters safely.

**Before ‚Üí After (idea)**

```java
// Before: SpEL with ?0 inside the expression (risky)
@Query("{ $where: ?#{ ?0 } }")
List<User> findWithExpr(String userExpr);

// After: switch to array-style in SpEL (workaround)
@Query("{ $where: ?#{ [0] } }")
List<User> findWithExprSafe(String userExpr);

// Or: avoid SpEL in the annotation entirely (preferred when feasible)
List<User> findByName(String name); // build dynamic parts in code
```

---
## Quick PR checklist

- [ ] Search for `@Query` / `@Aggregation` that contain SpEL (`?#{`).
- [ ] If SpEL is required, **replace** `?0` style with **array syntax** `[0]` inside the expression.
- [ ] Otherwise, move dynamic pieces into **custom repository code** and **bind parameters**.
- [ ] **Upgrade** Spring Data MongoDB to a **fixed release**.
- [ ] Add a **unit/integration test** that exercises the risky path with hostile input.

## Appendix ‚Äî the tiny command cheat sheet

**Find repository annotations**

```shell
rg -n "@Query|@Aggregation" --glob "**/*.java"
```

**Find SpEL blocks**

```shell
rg -n "?\#\{" --glob "**/*.java"
```

**Find ‚ÄúSpEL + positional param‚Äù**

```shell
rg -n "@Query\([^)]*\?\#\{[^)]*\?[0-9]" --glob "**/*.java"
```

